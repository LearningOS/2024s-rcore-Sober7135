# 简答作业

## 第一题

## 第二题
### 区别
1. **解锁时机**：
   - **Mutex1**：无论是否有等待任务，互斥锁都会立即解锁（代码第5行）。如果有任务在等待，它将从等待队列中弹出并被调度执行（代码第6-7行）。
   - **Mutex2**：互斥锁仅在确认没有等待任务时才会解锁（代码第19行）。如果有等待任务，将优先调度等待任务，然后才处理互斥锁的解锁。

2. **处理等待任务的策略**：
   - **Mutex1**：先解锁，然后处理等待队列。这种策略下，解锁操作与等待任务的调度是分开的。
   - **Mutex2**：在处理完所有等待任务后，才进行解锁操作。这保证了在有任务需要被唤醒时，互斥锁保持锁定状态。

### 可能导致的问题
1. **Mutex1的潜在问题**：
   - **竞态条件**：由于互斥锁一旦解锁，任何任务都有可能获取互斥锁，这可能导致刚从队列中被唤醒的任务在实际运行前互斥锁已被其他任务获取。这种情况下，原本应当被唤醒的任务可能会面临不必要的延迟或饥饿。
   - **优先级反转**：高优先级任务可能因为锁被低优先级任务意外获取而不能及时执行。

2. **Mutex2的优点**：
   - **避免竞态条件**：通过保持锁状态直到决定是否有任务需要被唤醒，Mutex2避免了可能的竞态条件，使系统在多任务调度和同步中表现得更为可靠和稳定。
   - **公平调度**：保证等待队列中的任务优先被唤醒和执行，从而实现更公平的任务调度。

# 报告

实现了死锁检测.

# 荣誉准则

1.  在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

2.  此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

维基百科.

3.  我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4.  我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
